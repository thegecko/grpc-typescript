/**
 * This file is auto-generated by protobuf-templates, do not edit
 */

// tslint:disable:max-classes-per-file
// tslint:disable:no-empty-interface
// tslint:disable:no-empty
// tslint:disable:variable-name

{{#*inline "importer"}}
{{#each nested}}
{{#if methods}}
import { EventEmitter } from "events";
{{else}}
{{> importer }}
{{/if}}
{{/each}}
{{/inline}}
{{> importer }}

{{> interfaces }}

export interface Client {
    name: string;
    rpcSender: (methodName: string, stream: MethodStream<any, any>) => void;
    readerFactory: (bytes: Uint8Array) => Reader;
    writerFactory: () => Writer;
}

{{#*inline "selector"}}
{{#each nested}}
{{#if fields}}
{{> type }}
{{else if methods}}
{{> service }}
{{else if values}}
{{> enum }}
{{else}}
{{> namespace }}
{{/if}}
{{/each}}
{{/inline}}
{{> selector }}

{{#*inline "namespace"}}

/**
 * Namespace {{@key}}
 */
export namespace {{@key}} {
    {{> selector }}
}
{{/inline}}

{{#*inline "service"}}

/**
 * Represents a {{@key}} service
 */
{{#empty methods}}
// tslint:disable-next-line:no-empty-interface
{{/empty}}
export class {{@key}} implements Client {

    public readonly name = "{{@key}}";

    /**
     * {{@key}} Constructor
     * @param rpcSender Function to deal with the encoded rpc messages
     * @param readerFactory Function to return a Reader object similar to protobufjs.Reader
     * @param writerFactory Function to return a Writer object similar to protobufjs.Writer
     */
    constructor(public rpcSender: ((methodName: string, stream: MethodStream<any, any>) => void) = null, public readerFactory: (bytes: Uint8Array) => Reader = null, public writerFactory: () => Writer = null) {
    }
{{#each methods}}

{{#if requestStream}}
{{#if responseStream}}
    public {{@key}}(): ReadWriteStream<{{@key}}MethodStream, Partial<{{this.requestType}}>> {
        const stream = new {{@key}}Stream(this.readerFactory, this.writerFactory);
        this.rpcSender("{{@key}}", stream);
        return stream;
    }
{{else}}
    public {{@key}}(callback?: (response: {{this.responseType}}) => void): WriteStream<Partial<{{this.requestType}}>> {
        const stream = new {{@key}}Stream(this.readerFactory, this.writerFactory);
        this.rpcSender("{{@key}}", stream);
        if (callback) {
            stream.on("end", response => {
                callback(response);
            });
        }
        return stream;
    }
{{/if}}
{{else}}
{{#if responseStream}}
    public {{@key}}(request: Partial<{{this.requestType}}>): ReadStream<{{@key}}MethodStream> {
        const stream = new {{@key}}Stream(this.readerFactory, this.writerFactory);
        this.rpcSender("{{@key}}", stream);
        stream.end(request);
        return stream;
    }
{{else}}
    public {{@key}}(request: Partial<{{this.requestType}}>, callback?: (response: {{this.responseType}}) => void): void {
        const stream = new {{@key}}Stream(this.readerFactory, this.writerFactory);
        this.rpcSender("{{@key}}", stream);
        if (callback) {
            stream.on("end", response => {
                callback(response);
            });
        }
        stream.end(request);
    }
{{/if}}
{{/if}}
{{/each}}
{{> selector }}
}
{{#each methods}}

export interface {{@key}}MethodStream {
    data: {{this.responseType}};
    end: {{this.responseType}};
}

export class {{@key}}Stream extends EventEmitter implements MethodStream<{{@key}}MethodStream, Partial<{{this.requestType}}>> {
    constructor(private readerFactory: (bytes: Uint8Array) => Reader = null, private writerFactory: () => Writer = null) {
        super();
    }

    public writeStream(data: Uint8Array) {
        this.emit("data", {{this.responseType}}.decode(this.readerFactory(data)));
    }

    public endStream(data?: Uint8Array) {
        if (!data) return this.emit("end");
        this.emit("end", {{this.responseType}}.decode(this.readerFactory(data)));
    }

    public write(message: Partial<{{this.requestType}}>) {
        message = new {{this.requestType}}(message);
        this.emit("dataStream", {{this.requestType}}.encode(this.writerFactory(), message).finish());
    }

    public end(message?: Partial<{{this.requestType}}>) {
        if (!message) return this.emit("endStream");

        message = new {{this.requestType}}(message);
        this.emit("endStream", {{this.requestType}}.encode(this.writerFactory(), message).finish());
    }
}
{{/each}}
{{/inline}}

{{#*inline "type"}}

{{> messages }}
{{#if nested}}

/**
 * Namespace {{@key}}
 */
export namespace {{@key}} {
    {{> selector }}
}
{{/if}}
{{/inline}}

{{#*inline "enum"}}

/**
 * {{@key}} enum
 */
{{#empty values}}
// tslint:disable-next-line:no-empty-interface
{{/empty}}
export enum {{@key}} {
{{#each values}}
    {{@key}} = {{this}},
{{/each}}
}
{{/inline}}

/**
 * This file is auto-generated by protobuf-templates, do not edit
 */

// tslint:disable:max-classes-per-file
// tslint:disable:no-empty-interface
// tslint:disable:no-empty
// tslint:disable:variable-name

{{#*inline "importer"}}
{{#each nested}}
{{#if methods}}
import { EventEmitter } from "events";
{{else}}
{{> importer }}
{{/if}}
{{/each}}
{{/inline}}
{{> importer }}

{{> interfaces }}

export interface Server {
    name: string;
    readerFactory: (bytes: Uint8Array) => Reader;
    writerFactory: () => Writer;
    rpcHandler(methodName: string): MethodStream<any, any>;
}

{{#*inline "selector"}}
{{#each nested}}
{{#if fields}}
{{> type }}
{{else if methods}}
{{> service }}
{{else if values}}
{{> enum }}
{{else}}
{{> namespace }}
{{/if}}
{{/each}}
{{/inline}}
{{> selector }}

{{#*inline "namespace"}}

/**
 * Namespace {{@key}}
 */
export namespace {{@key}} {
    {{> selector }}
}
{{/inline}}

{{#*inline "service"}}

/**
 * Represents a {{@key}} service
 */
{{#empty methods}}
// tslint:disable-next-line:no-empty-interface
{{/empty}}
export abstract class {{@key}} implements Server {

    public readonly name = "{{@key}}";

    /**
     * {{@key}} Constructor
     * @param readerFactory Function to return a Reader object similar to protobufjs.Reader
     * @param writerFactory Function to return a Writer object similar to protobufjs.Writer
     */
    constructor(public readerFactory: (bytes: Uint8Array) => Reader = null, public writerFactory: () => Writer = null) {
    }

    /**
     * Handle incoming encoded rpc messages
     * @param methodName The method to invoke
     * @returns stream-like object to interract with
     */
    public rpcHandler(methodName: {{#each methods}}"{{@key}}"{{#unless @last}} | {{/unless}}{{/each}}): MethodStream<any, any> {
        let stream = null;

        switch (methodName) {
        {{#each methods}}
            case "{{@key}}":
                stream = new {{@key}}Stream(this.readerFactory, this.writerFactory);
            {{#if requestStream}}
            {{#if responseStream}}
                this.{{@key}}(stream);
            {{else}}
                this.{{@key}}(stream, response => {
                    stream.end(response);
                });
            {{/if}}
            {{else}}
            {{#if responseStream}}
                stream.on("end", request => {
                    this.{{@key}}(request, stream);
                });
            {{else}}
                stream.on("end", request => {
                    this.{{@key}}(request, response => {
                        stream.end(response);
                    });
                });
            {{/if}}
            {{/if}}
                break;
        {{/each}}
        }

        return stream;
    }
{{#each methods}}

{{#if requestStream}}
{{#if responseStream}}
    protected abstract {{@key}}(stream: ReadWriteStream<{{@key}}MethodStream, Partial<{{this.responseType}}>>): void;
{{else}}
    protected abstract {{@key}}(requestStream: ReadStream<{{@key}}MethodStream>, callback: (response?: Partial<{{this.responseType}}>) => void): void;
{{/if}}
{{else}}
{{#if responseStream}}
    protected abstract {{@key}}(request: {{this.requestType}}, responseStream: WriteStream<Partial<{{this.responseType}}>>): void;
{{else}}
    protected abstract {{@key}}(request: {{this.requestType}}, callback: (response?: Partial<{{this.responseType}}>) => void): void;
{{/if}}
{{/if}}
{{/each}}
{{> selector }}
}
{{#each methods}}

export interface {{@key}}MethodStream {
    data: {{this.requestType}};
    end: {{this.requestType}};
}

export class {{@key}}Stream extends EventEmitter implements MethodStream<{{@key}}MethodStream, Partial<{{this.responseType}}>> {
    constructor(private readerFactory: (bytes: Uint8Array) => Reader = null, private writerFactory: () => Writer = null) {
        super();
    }

    public writeStream(data: Uint8Array) {
        this.emit("data", {{this.requestType}}.decode(this.readerFactory(data)));
    }

    public endStream(data?: Uint8Array) {
        if (!data) return this.emit("end");
        this.emit("end", {{this.requestType}}.decode(this.readerFactory(data)));
    }

    public write(message: Partial<{{this.responseType}}>) {
        message = new {{this.responseType}}(message);
        this.emit("dataStream", {{this.responseType}}.encode(this.writerFactory(), message).finish());
    }

    public end(message?: Partial<{{this.responseType}}>) {
        if (!message) return this.emit("endStream");

        message = new {{this.responseType}}(message);
        this.emit("endStream", {{this.responseType}}.encode(this.writerFactory(), message).finish());
    }
}
{{/each}}
{{/inline}}

{{#*inline "type"}}

{{> messages }}
{{#if nested}}

/**
 * Namespace {{@key}}
 */
export namespace {{@key}} {
    {{> selector }}
}
{{/if}}
{{/inline}}

{{#*inline "enum"}}

/**
 * {{@key}} enum
 */
{{#empty values}}
// tslint:disable-next-line:no-empty-interface
{{/empty}}
export enum {{@key}} {
{{#each values}}
    {{@key}} = {{this}},
{{/each}}
}
{{/inline}}

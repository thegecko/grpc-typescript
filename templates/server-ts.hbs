/**
 * This file is auto-generated by protobuf-templates, do not edit
 */

// tslint:disable:max-classes-per-file

/** Wire format reader using `Uint8Array` if available, otherwise `Array`. */
export interface Reader {

    /**
     * Creates a new reader using the specified buffer.
     * @param buffer Buffer to read from
     * @returns A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
     * @throws {Error} If `buffer` is not a valid buffer
     */
    // static create(buffer: (Uint8Array|Buffer)): (Reader|BufferReader);

    /** Read buffer. */
    buf: Uint8Array;

    /** Read buffer position. */
    pos: number;

    /** Read buffer length. */
    len: number;

    /**
     * Reads a varint as an unsigned 32 bit value.
     * @returns Value read
     */
    uint32(): number;

    /**
     * Reads a varint as a signed 32 bit value.
     * @returns Value read
     */
    int32(): number;

    /**
     * Reads a zig-zag encoded varint as a signed 32 bit value.
     * @returns Value read
     */
    sint32(): number;

    /**
     * Reads a varint as a signed 64 bit value.
     * @returns Value read
     */
    int64(): number; // Long;

    /**
     * Reads a varint as an unsigned 64 bit value.
     * @returns Value read
     */
    uint64(): number; // Long;

    /**
     * Reads a zig-zag encoded varint as a signed 64 bit value.
     * @returns Value read
     */
    sint64(): number; // Long;

    /**
     * Reads a varint as a boolean.
     * @returns Value read
     */
    bool(): boolean;

    /**
     * Reads fixed 32 bits as an unsigned 32 bit integer.
     * @returns Value read
     */
    fixed32(): number;

    /**
     * Reads fixed 32 bits as a signed 32 bit integer.
     * @returns Value read
     */
    sfixed32(): number;

    /**
     * Reads fixed 64 bits.
     * @returns Value read
     */
    fixed64(): number; // Long;

    /**
     * Reads zig-zag encoded fixed 64 bits.
     * @returns Value read
     */
    sfixed64(): number; // Long;

    /**
     * Reads a float (32 bit) as a number.
     * @returns Value read
     */
    float(): number;

    /**
     * Reads a double (64 bit float) as a number.
     * @returns Value read
     */
    double(): number;

    /**
     * Reads a sequence of bytes preceeded by its length as a varint.
     * @returns Value read
     */
    bytes(): Uint8Array;

    /**
     * Reads a string preceeded by its byte length as a varint.
     * @returns Value read
     */
    string(): string;

    /**
     * Skips the specified number of bytes if specified, otherwise skips a varint.
     * @param [length] Length if known, otherwise a varint is assumed
     * @returns `this`
     */
    skip(length?: number): Reader;

    /**
     * Skips the next element of the specified wire type.
     * @param wireType Wire type received
     * @returns `this`
     */
    skipType(wireType: number): Reader;
}

/** Wire format writer using `Uint8Array` if available, otherwise `Array`. */
export interface Writer {

    /**
     * Creates a new writer.
     * @returns A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
     */
    // static create(): (BufferWriter|Writer);

    /**
     * Allocates a buffer of the specified size.
     * @param size Buffer size
     * @returns Buffer
     */
    // static alloc(size: number): Uint8Array;

    /** Current length. */
    len: number;

    /** Operations head. */
    head: object;

    /** Operations tail */
    tail: object;

    /** Linked forked states. */
    states: (object|null);

    /**
     * Writes an unsigned 32 bit value as a varint.
     * @param value Value to write
     * @returns `this`
     */
    uint32(value: number): Writer;

    /**
     * Writes a signed 32 bit value as a varint.
     * @param value Value to write
     * @returns `this`
     */
    int32(value: number): Writer;

    /**
     * Writes a 32 bit value as a varint, zig-zag encoded.
     * @param value Value to write
     * @returns `this`
     */
    sint32(value: number): Writer;

    /**
     * Writes an unsigned 64 bit value as a varint.
     * @param value Value to write
     * @returns `this`
     * @throws {TypeError} If `value` is a string and no long library is present.
     */
    uint64(value: (number|string)): Writer; // Long;

    /**
     * Writes a signed 64 bit value as a varint.
     * @param value Value to write
     * @returns `this`
     * @throws {TypeError} If `value` is a string and no long library is present.
     */
    int64(value: (number|string)): Writer; // Long;

    /**
     * Writes a signed 64 bit value as a varint, zig-zag encoded.
     * @param value Value to write
     * @returns `this`
     * @throws {TypeError} If `value` is a string and no long library is present.
     */
    sint64(value: (number|string)): Writer; // Long;

    /**
     * Writes a boolish value as a varint.
     * @param value Value to write
     * @returns `this`
     */
    bool(value: boolean): Writer;

    /**
     * Writes an unsigned 32 bit value as fixed 32 bits.
     * @param value Value to write
     * @returns `this`
     */
    fixed32(value: number): Writer;

    /**
     * Writes a signed 32 bit value as fixed 32 bits.
     * @param value Value to write
     * @returns `this`
     */
    sfixed32(value: number): Writer;

    /**
     * Writes an unsigned 64 bit value as fixed 64 bits.
     * @param value Value to write
     * @returns `this`
     * @throws {TypeError} If `value` is a string and no long library is present.
     */
    fixed64(value: (number|string)): Writer; // Long;

    /**
     * Writes a signed 64 bit value as fixed 64 bits.
     * @param value Value to write
     * @returns `this`
     * @throws {TypeError} If `value` is a string and no long library is present.
     */
    sfixed64(value: (number|string)): Writer; // Long;

    /**
     * Writes a float (32 bit).
     * @param value Value to write
     * @returns `this`
     */
    float(value: number): Writer;

    /**
     * Writes a double (64 bit float).
     * @param value Value to write
     * @returns `this`
     */
    double(value: number): Writer;

    /**
     * Writes a sequence of bytes.
     * @param value Buffer or base64 encoded string to write
     * @returns `this`
     */
    bytes(value: (Uint8Array|string)): Writer;

    /**
     * Writes a string.
     * @param value Value to write
     * @returns `this`
     */
    string(value: string): Writer;

    /**
     * Forks this writer's state by pushing it to a stack.
     * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
     * @returns `this`
     */
    fork(): Writer;

    /**
     * Resets this instance to the last state.
     * @returns `this`
     */
    reset(): Writer;

    /**
     * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
     * @returns `this`
     */
    ldelim(): Writer;

    /**
     * Finishes the write operation.
     * @returns Finished buffer
     */
    finish(): Uint8Array;
}

{{#*inline "selector"}}
{{#each nested}}
{{#if fields}}
{{> type }}
{{else if methods}}
{{> service }}
{{else if values}}
{{> enum }}
{{else}}
{{> namespace }}
{{/if}}
{{/each}}
{{/inline}}

{{#*inline "namespace"}}

/**
 * Namespace {{@key}}
 */
export namespace {{@key}} {
    {{> selector }}
}
{{/inline}}

{{#*inline "service"}}

/**
 * Represents a {{@key}} service
 */
{{#each methods}}
{{else}}
// tslint:disable-next-line:no-empty-interface
{{/each}}
export abstract class {{@key}} {

    private _methods = null;

    /**
     * Calls {{@key}}
     * @param request {{this.requestType}} message or plain object
     * @param callback Node-style callback called with the error, if any, {{this.responseType}}
     */
    constructor(private _reader: Reader, private _writer: Writer) {
        this._methods = {
        {{#each methods}}
            {{@key}}: { req: null, res: null },
        {{/each}}
        };
    }
{{#each methods}}

    /**
     * Calls {{@key}}
     * @param request {{this.requestType}} message or plain object
     * @param callback Node-style callback called with the error, if any, {{this.responseType}}
     */
    protected abstract {{@key}}(request: {{this.requestType}}, callback: (error: Error|null, response?: {{this.responseType}}) => void): void;
{{/each}}
{{> selector }}
}
{{/inline}}

{{#*inline "type"}}

/**
 * Properties of a {{@key}} message
 */
{{#each fields}}
{{else}}
// tslint:disable-next-line:no-empty-interface
{{/each}}
export class {{@key}} {
{{#each fields}}

    /**
     * {{@key}}
     */
{{#is rule "repeated"}}
    public {{@key}}?: {{memberType this}}[];
{{else}}
    public {{@key}}?: {{memberType this}};
{{/is}}
{{/each}}

    /**
     * Encodes the specified {{@key}} message
     * @param message {{@key}} message or plain object to encode
     * @param [writer] Writer to encode to
     * @returns Writer
     */
    public static encode(message: {{@key}}, writer?: Writer): Writer {
    {{#each fields}}
    {{#is rule "repeated"}}
        if (message.{{@key}} !== null && message.{{@key}}.length) {
            for (const item of message.newMessages) {
            {{#isScalar this}}
                writer.{{this.type}}(item);
            {{else}}
                {{memberType this}}.encode(item, writer);
            {{/isScalar}}
            }
        }
    {{else}}
        if (message.{{@key}} !== null && message.hasOwnProperty("{{@key}}")) {
        {{#isScalar this}}
            writer.{{this.type}}(message.{{@key}});
        {{else}}
            {{memberType this}}.encode(message.{{@key}}, writer);
        {{/isScalar}}
        }
    {{/is}}
    {{/each}}

        return writer;
    }

    /**
     * Decodes a {{@key}} message from the specified reader or buffer
     * @param reader Reader to decode from
     * @returns {{@key}}
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: Reader): {{@key}} {
        const message = new {{@key}}();
        while (reader.pos < reader.len) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            {{#each fields}}
                case {{id}}:
                {{#is rule "repeated"}}
                    if (!(message.{{@key}} && message.{{@key}}.length)) {
                        message.{{@key}} = [];
                    }
                {{#isScalar this}}
                    message.{{@key}}.push(reader.{{type}}());
                {{else}}
                    message.{{@key}}.push({{memberType this}}.decode(reader));
                {{/isScalar}}
                {{else}}
                {{#isScalar this}}
                    message.{{@key}} = reader.{{type}}();
                {{else}}
                    {{memberType this}}.decode(reader);
                {{/isScalar}}
                {{/is}}
                    break;
            {{/each}}
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    }
}
{{#if nested}}

/**
 * Namespace {{@key}}
 */
export namespace {{@key}} {
    {{> selector }}
}
{{/if}}
{{/inline}}

{{#*inline "enum"}}

/**
 * {{@key}} enum
 */
{{#each values}}
{{else}}
// tslint:disable-next-line:no-empty-interface
{{/each}}
export enum {{@key}} {
{{#each values}}
    {{@key}} = {{this}},
{{/each}}
}
{{/inline}}

{{> selector }}

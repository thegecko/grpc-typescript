/**
 * This file is auto-generated by protobuf-templates, do not edit
 */

// tslint:disable:max-classes-per-file
// tslint:disable:no-empty-interface
// tslint:disable:no-empty
// tslint:disable:variable-name

/** Wire format reader using `Uint8Array` if available, otherwise `Array`. */
export interface Reader {

    /** Read buffer position. */
    pos: number;

    /** Read buffer length. */
    len: number;

    uint32(): number;
    int32(): number;
    sint32(): number;
    int64(): number; // Long;
    uint64(): number; // Long;
    sint64(): number; // Long;
    bool(): boolean;
    fixed32(): number;
    sfixed32(): number;
    fixed64(): number; // Long;
    sfixed64(): number; // Long;
    float(): number;
    double(): number;
    bytes(): Uint8Array;
    string(): string;
    skip(length?: number): Reader;
    skipType(wireType: number): Reader;
}

/** Wire format writer using `Uint8Array` if available, otherwise `Array`. */
export interface Writer {
    uint32(value: number): Writer;
    int32(value: number): Writer;
    sint32(value: number): Writer;
    uint64(value: (number|string)): Writer; // Long;
    int64(value: (number|string)): Writer; // Long;
    sint64(value: (number|string)): Writer; // Long;
    bool(value: boolean): Writer;
    fixed32(value: number): Writer;
    sfixed32(value: number): Writer;
    fixed64(value: (number|string)): Writer; // Long;
    sfixed64(value: (number|string)): Writer; // Long;
    float(value: number): Writer;
    double(value: number): Writer;
    bytes(value: (Uint8Array|string)): Writer;
    string(value: string): Writer;

    /**
     * Forks this writer's state by pushing it to a stack.
     * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
     * @returns `this`
     */
    fork(): Writer;

    /**
     * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
     * @returns `this`
     */
    ldelim(): Writer;

    /**
     * Finishes the write operation.
     * @returns Finished buffer
     */
    finish(): Uint8Array;
}

{{#*inline "selector"}}
{{#each nested}}
{{#if fields}}
{{> type }}
{{else if methods}}
{{> service }}
{{else if values}}
{{> enum }}
{{else}}
{{> namespace }}
{{/if}}
{{/each}}
{{/inline}}

{{#*inline "namespace"}}

/**
 * Namespace {{@key}}
 */
export namespace {{@key}} {
    {{> selector }}
}
{{/inline}}

{{#*inline "service"}}

/**
 * Represents a {{@key}} service
 */
{{#empty methods}}
// tslint:disable-next-line:no-empty-interface
{{/empty}}
export abstract class {{@key}} {

    /**
     * {{@key}} Constructor
     * @param readerFactory Function to return a Reader object similar to protobufjs.Reader
     * @param writerFactory Function to return a Writer object similar to protobufjs.Writer
     */
    constructor(private readerFactory: (bytes: Uint8Array) => Reader, private writerFactory: () => Writer) {
    }

    /**
     * Handle incoming rpc messages
     * @param methodName The method to invoke
     * @param bytes The encoded protobuf message
     * @param callback Node-style callback function returned with an encoded protobuf response
     */
    public rpcHandler(methodName: {{#each methods}}"{{@key}}"{{#unless @last}} | {{/unless}}{{/each}}, bytes: Uint8Array, callback?: (error: Error, response?: Uint8Array) => void): void {
        switch (methodName) {
        {{#each methods}}
            case "{{@key}}":
                this.{{@key}}({{this.requestType}}.decode(this.readerFactory(bytes)), (error, response) => {
                    if (callback) callback(error, {{this.responseType}}.encode(this.writerFactory(), response).finish());
                });
                break;
        {{/each}}
        }
    }
{{#each methods}}

    protected abstract {{@key}}(request: {{this.requestType}}, callback: (error: Error, response?: Partial<{{this.responseType}}>) => void): void;
{{/each}}
{{> selector }}
}
{{/inline}}

{{#*inline "type"}}

/**
 * Properties of a {{@key}} message
 */
{{#empty fields}}
// tslint:disable-next-line:no-empty-interface
{{/empty}}
export class {{@key}} {
{{#each fields}}

    /**
     * {{@key}}
     */
{{#is rule "repeated"}}
    public {{@key}}?: {{memberType this}}[] = [];
{{else}}
    public {{@key}}?: {{memberType this}} = {{{defaultValue this}}};
{{/is}}
{{/each}}

    constructor(props?: Partial<{{@key}}>) {
        if (props) {
        {{#each fields}}
            this.{{@key}} = props.{{@key}};
        {{/each}}
        }
    }

    public static encode(writer: Writer, _partial: Partial<{{@key}}>): Writer {
    {{#empty fields}}
    {{else}}
        const message = new {{@key}}(_partial);

    {{/empty}}
    {{#each fields}}
    {{#if keyType}}
    {{#once}}
        function keys<T>(obj: T) {
            return Object.keys(obj) as Array<(keyof T)>;
        }
    {{/once}}
        if (message.{{@key}} !== null) {
            for (const key of keys(message.{{@key}})) {
                writer.uint32({{wireKey "repeated" id}}).fork()
                .uint32({{wireKey keyType 1}}).{{keyType}}(key)
                .uint32({{wireKey type 2}}).{{wireType this}}(message.{{@key}}[key])
                .ldelim();
            }
        }
    {{else}}
        if (message.{{@key}} !== null) {
        {{#is rule "repeated"}}
        {{#if options.enum}}
            writer.uint32({{wireKey "repeated" id}}).fork();
            message.{{@key}}.forEach(item => {
                writer.{{wireType this}}(item);
            });
            writer.ldelim();
        {{else}}
            message.{{@key}}.forEach(item => {
            {{#isScalar this}}
                writer.uint32({{wireKey "repeated" id}}).{{wireType this}}(item);
            {{else}}
                {{memberType this}}.encode(writer.uint32({{wireKey "embedded" id}}).fork(), item).ldelim();
            {{/isScalar}}
            });
        {{/if}}
        {{else}}
        {{#isScalar this}}
            writer.uint32({{wireKey type id}}).{{wireType this}}(message.{{@key}});
        {{else}}
            {{memberType this}}.encode(writer.uint32({{wireKey "embedded" id}}).fork(), message.{{@key}}).ldelim();
        {{/isScalar}}
        {{/is}}
        }
    {{/if}}
    {{/each}}

        return writer;
    }

    public static decode(reader: Reader, length?: number): {{@key}} {
        const message = new {{@key}}();
        const end = length ? reader.pos + length : reader.len;

        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            {{#each fields}}
                case {{id}}:
                {{#if keyType}}
                    reader.skip().pos++;
                    if (!message.{{@key}}) message.{{@key}} = {};
                    const key = reader.{{keyType}}();
                    reader.pos++;
                    message.{{@key}}[key] = reader.{{wireType this}}();
                {{else}}
                {{#is rule "repeated"}}
                    if (!message.{{@key}}) message.{{@key}} = [];
                {{#if options.enum}}
                    if ((tag & 7) === 2) {
                        while (reader.pos < (reader.uint32() + reader.pos)) {
                            message.{{@key}}.push(reader.{{wireType this}}());
                        }
                    } else {
                        message.{{@key}}.push(reader.{{wireType this}}());
                    }
                {{else}}
                {{#isScalar this}}
                    message.{{@key}}.push(reader.{{wireType this}}());
                {{else}}
                    message.{{@key}}.push({{memberType this}}.decode(reader, reader.uint32()));
                {{/isScalar}}
                {{/if}}
                {{else}}
                {{#isScalar this}}
                    message.{{@key}} = reader.{{wireType this}}();
                {{else}}
                    message.{{@key}} = {{memberType this}}.decode(reader, reader.uint32());
                {{/isScalar}}
                {{/is}}
                {{/if}}
                    break;
            {{/each}}
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }

        return message;
    }
}
{{#if nested}}

/**
 * Namespace {{@key}}
 */
export namespace {{@key}} {
    {{> selector }}
}
{{/if}}
{{/inline}}

{{#*inline "enum"}}

/**
 * {{@key}} enum
 */
{{#empty values}}
// tslint:disable-next-line:no-empty-interface
{{/empty}}
export enum {{@key}} {
{{#each values}}
    {{@key}} = {{this}},
{{/each}}
}
{{/inline}}

{{> selector }}
